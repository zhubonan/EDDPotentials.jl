var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Public-API","page":"API","title":"Public API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Builder\nlink!","category":"page"},{"location":"api/#EDDPotentials.Builder","page":"API","title":"EDDPotentials.Builder","text":"Builder\n\nThe Builder is the main object that stores states and options for training and using the potentials.\n\n\n\n\n\n","category":"type"},{"location":"api/#EDDPotentials.link!","page":"API","title":"EDDPotentials.link!","text":"link!(builder::Builder)\n\nRun automated iterative building cycles.\n\n\n\n\n\n","category":"function"},{"location":"python_tools/#Using-Python-tools","page":"Python Tools","title":"Using Python tools","text":"","category":"section"},{"location":"python_tools/#Setting-up-PyCall.jl","page":"Python Tools","title":"Setting up PyCall.jl","text":"","category":"section"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"PyCall.jl is used to call python funcition define the classes that can use the trained models are calculator. ","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"Guides for setting it up can be found at its home page. On Linux, this is as simple as (from scratch): ","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"conda create -n pycall_env python ase phonopy <other packages2> <other package2> ...\nconda activate pycall\nexport PYTHON=`which python`\njulia -e 'using Pkg; Pkg.add(\"PyCall\"); Pkg.build(\"PyCall\")'\nunset PYTHON","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"The key is to build the PyCall.jl package with a PYTHON environmental variable that points to the interpreter of the virtual environment to be used for Julia. ","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"You can verify if the environment is up and running by importing ase in the Julia REPL:","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"julia> using PyCall\n\njulia> pyimport(\"ase\")\n","category":"page"},{"location":"python_tools/#Phonon-calculations","page":"Python Tools","title":"Phonon calculations","text":"","category":"section"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"Phonon calculations requires a fully relaxed structures, so one has to relax the structure first:","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"julia> builder = Builder(\"link.toml\")  # Load the train model\n\njulia> @show builder.state.iteration  # Check if the latest iteration has been detected\n\njulia> res = read_res(\"<path to SHLEX file>\")  # Read in the structure file\n\njulia> calc = NNCalc(res, builder.cf, load_ensemble(builder))   # Construct a NNCalc object\n\njulia> EDDPotentials.optimise!(calc |> VariableCellCalc)   # Optimise with variable cell shape","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"Finally, we run the finite displacement calculations:","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"julia> using EDDPotentialsTools\n\njulia> EDDPotentialsTools.run_phonon(calc;outdir=\"phonon\")","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"This writes the YAML files and FORCE_SETS and phonopy_params.yaml files into a new folder called phonon. One can use phonopy for further processing from this point.","category":"page"},{"location":"python_tools/","page":"Python Tools","title":"Python Tools","text":"note: Note\nThe sumo package provides a sumo-phonon-bandplot command which can be used to run a band structure calculation using phonopy with automatically generated band pathways. ","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#A-potential-for-carbon","page":"Getting Started","title":"A potential for carbon","text":"","category":"section"},{"location":"getting_started/#Metrics","page":"Getting Started","title":"Metrics","text":"","category":"section"},{"location":"getting_started/#Properties","page":"Getting Started","title":"Properties","text":"","category":"section"},{"location":"airss/#Ab-initio-Random-Structure-Searching-(AIRSS)","page":"AIRSS Background","title":"Ab initio Random Structure Searching (AIRSS)","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"Ab initio random structure searching (AIRSS)[1][2] is an approach to search for low energy structure by simply generating random structures, followed by local optimisation. Local optimisation is a relatively simple and mathematically well-established, it found a nearby local minimum in the configuration space by simply going down-hill in energy. The potential energy surface (PES) can be divided into many basins-of-attraction. Performing a local optimisation inside a basin would lead us to bottom of this basin, e.g. the local minimum.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"From first glance, such random sampling approach is deemed to fail for complex and high-dimensional configuration space due to the existence of many high energy local minima, making the chance of landing in the basin of attraction of the global minimum diminishing. However, one must not forget that the potential energy surface (PES) is a physical quantity, and hence their structure follow certain rules. While the number of high energy local minima may be overwhelming, the chance of landing into a basins-of-attraction is proportional to its hypervolume, and the lower the energy, the larger the hypervolume, favouring even a random sampler. In addition, we know that a large portion of the configuration space is not likely to contain any low energy minima - the atoms the bonds between them do have well-known finite sizes. The region of the PES including atoms very close to each other are unlikely to have any low energy minima, and hence can be excluded from sampling. Likewise, structures with atoms far apart from each other should also be excluded from sampling. With a few physical constraints, such as the species-wise minimum separations, including symmetry operations, a simple random search approach can be made highly efficient for locating the ground state structure and other low energy polymorphs. While the structures are randomly generated, the parameters controlling the generation process are not randomly chosen - they are motivated by physical reasons.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The phrase ab initio not only means that this approach can be used with first-principles methods for energy evaluation, but also that it should be used with them, since it is the physical nature of the PES that is been exploited here. While random search can be applied with parameterized interatomic potentials, the latter are unlikely to reproduce the true PES especially in the region far away from fitted phases. Hence, it is not a surprise if random search does not work well in those cases.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"A consequence of random sampling is that the computational workload can be made fully parallel and distributed. There is no need to coordinate the search as a whole, each worker can work independently little or no inter-communication at all. In constrast, global optimisation methods such as basin hopping, requires each calculation to be performed in serial. Population based approaches such as genetic algorithms and particle swarm optimisation allow certain degree of parallelism within a single generation (tenth of structures), but each generation still have to be evaluated iteratively.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"This means that for random searching:","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The underlying DFT calculations can be parallelised over only a few   CPUs each, maximising the parallel efficiently which otherwise can   drop sharply with increasing core counts.\nThe elimination of iterative process means there is no dilemma of   exploration or exploitation.\nA further consequence is that the DFT calculations can be performed   at relatively low basis set qulaity and accuracy to maximise the   speed, usually at several times lower in the cost compared to normal   calculations.\nIn addition, most structures include and perserv symmetry operations   throughout the process, which can be used to speed-up DFT   calculations by several folds.","category":"page"},{"location":"airss/#Ingredients-of-a-search","page":"AIRSS Background","title":"Ingredients of a search","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"This section gives a brief introduction of how to run a search using airss along.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The searching process is rather simple: a random structure is generated and subsequently relaxed. However, both steps needs to be optimised for efficient searching.","category":"page"},{"location":"airss/#Structure-generation","page":"AIRSS Background","title":"Structure generation","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"In particular, the random structure should be not generated purely \\\"randomly\\\", but instead should based on a set of pre-determined constraints, to ensure that the output structures are physically sound. If not done so, the search can be rather inefficient[1][2][3] (often incorrectly interpreted as baseline).","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The structure generation process is done by the buildcell program, which takes a CASTEP cell file style input. The key quantities pass for providing the constraints are:","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"Estimated volume\nSpecies-wise minimum separations\nNumber of symmetry operations to include","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The question is: how can one know this prior to even performing the search? One simple way is to perform a short search with some guessed values. Such search may not find the true ground state, but the low energy structure would be able to provide the cues of what a ground state structure may look like. The first two parameters can thereby be estimated from the low energy structure of such \\\"pilot\\\" search. Alternatively, if there are known experimental structure, the first two parameters can be estimated from those as well.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"tip: Tip\ncat <xxx>.res | cryan -g is your friend for exacting these parameters. If the input structure is not in the SHELX format, the cabal tool can be used to convert it into that!","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"If one looks at typically polymorphs of a compounds, they do not vary too much (say \\< 20%) in terms of density and bond lengths. The species-wise minimum separation may be inferred from that of chemically similar materials. The exact values of the first two parameters would not make a huge difference in terms of search efficiency as long as they are sensible. In fact, one may want to use minimum separation drawn randomly from a certain","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"Finally, one may want to include symmetry operations in the generated structures - experimental structures are rarely P1 after all. Typically, two to four symmetry operations are included in the generated structure. The actual structure may gain more symmetry during the geometry operatimisation process, so the it is no necessary to have chosen specific space group in the first place.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"note: Note\nA side issue of imposing symmetry operations is that once a space group is chosen, the multiplicity of a atom will not change during subsequent relaxations. For example, atoms at the general positions will not be able to move to special positions. The default rule in airss is to maximise the occupation of general positions, which reduces the overall degrees of freedom. This also seems to follow the trend in most known crystals, but there can be exceptions. More special positions can be occupied by specifying the #ADJGEN setting. Mind that the general positions of a low symmetry space group can still become special positions of a higher symmetry one or that of a smaller unit cell.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The template cell file generate by gencell contains other default settings which will not be detailed here.","category":"page"},{"location":"airss/#DFT-relaxation","page":"AIRSS Background","title":"DFT relaxation","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"Each generated structure needs to be relaxed to a local minimium by some means. First-principles based methods are preferable as they provide realistic potential energy surfaces that are relatively smooth. Typically, this is done by CASTEP[4] , although other plane wave DFT code may also be used as well. CASTEP is preferred because it is well tested for this kind of tasks. It has robust electronic and ionic minimisation routines and soft pseudopotentials (QC5) optimised for throughput. The self-adaptive parallelisation in CASTEP also make it easy to deploy calculations on computing resources, since no manual input of parallelisation scheme is needed.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The typical setting is to use the QC5 pseudopotentials that requires very low cut off energies (300 - 340 eV) in order to maximise the speed. These potentials are probably not accurate enough for regular calculations, but they are sufficient for sampling the potential energy surfaces. The depth and the relative positions the local minima may be slightly wrong, but using them would be allow us to local these low energy structure much faster. Since there is no ranking taking place during the search to direct the sampling region (e.g. unlike GA or PSO), it is not necessary to obtain accurate energy and structures at this stage. In the end, a set of high quality calculations (typically using the C19 pseudopotential set) needs be applied to refine the results and obtain reliable energy orderings. This process is applied to only a subset of low energy structures that are already near the local minimum needs to be processed.","category":"page"},{"location":"airss/#When-to-(not)-stop","page":"AIRSS Background","title":"When to (not) stop","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"In crystal structure prediction, there is no way to make sure the ground state structure found is indeed true ground state, unless one performs a exhaustive sampling of the potential energy surface, which is impractical for any high-dimensional space. However, for a single search, ones still have to have a stopping criteria.","category":"page"},{"location":"airss/#The-**AIRSS**-package","page":"AIRSS Background","title":"The AIRSS package","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The AIRSS package is a open-source collection of tools and scripts for performing ab initio random structure searching (AIRSS) (which confusinly has the same name), and analysing the results. The key components of this package includes:","category":"page"},{"location":"airss/#buildcell","page":"AIRSS Background","title":"buildcell","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The main work horse for generating structures. This file reads a input seed file from stdin and outputs generated structuer in stdout. Both input and outputs files are in the CASTEP\\'s cell format, and the former contains special directives on how the random Structure should be generated.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"It is often useful to generate a initial cell using the gencell utility with gencell <volume> <units> [<specie> <number>]. For example to search for SrTiO3, one can input:","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"gencell 60 4 Sr 1 Ti 1 O 3","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"This prepares a seed to search for four formula units of SrTiO3, each formula unit is expected to have a volume of 60 mathrmÅ^3.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The content of the generated file 4SrTiO3.cell is shown below:","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"%BLOCK LATTICE_CART\n3.914865 0 0\n0 3.914865 0\n0 0 3.914865\n%ENDBLOCK LATTICE_CART\n\n#VARVOL=60\n\n%BLOCK POSITIONS_FRAC\nSr 0.0 0.0 0.0 # Sr1 % NUM=1\nSr 0.0 0.0 0.0 # Sr2 % NUM=1\nSr 0.0 0.0 0.0 # Sr3 % NUM=1\nSr 0.0 0.0 0.0 # Sr4 % NUM=1\nTi 0.0 0.0 0.0 # Ti1 % NUM=1\nTi 0.0 0.0 0.0 # Ti2 % NUM=1\nTi 0.0 0.0 0.0 # Ti3 % NUM=1\nTi 0.0 0.0 0.0 # Ti4 % NUM=1\nO 0.0 0.0 0.0 # O1 % NUM=1\nO 0.0 0.0 0.0 # O2 % NUM=1\nO 0.0 0.0 0.0 # O3 % NUM=1\nO 0.0 0.0 0.0 # O4 % NUM=1\nO 0.0 0.0 0.0 # O5 % NUM=1\nO 0.0 0.0 0.0 # O6 % NUM=1\nO 0.0 0.0 0.0 # O7 % NUM=1\nO 0.0 0.0 0.0 # O8 % NUM=1\nO 0.0 0.0 0.0 # O9 % NUM=1\nO 0.0 0.0 0.0 # O10 % NUM=1\nO 0.0 0.0 0.0 # O11 % NUM=1\nO 0.0 0.0 0.0 # O12 % NUM=1\n%ENDBLOCK POSITIONS_FRAC\n\n##SPECIES=Sr,Ti,O\n##NATOM=3-9\n##FOCUS=3\n\n#SYMMOPS=2-4\n##SGRANK=20\n#NFORM=1\n##ADJGEN=0-1\n#SLACK=0.25\n#OVERLAP=0.1\n#MINSEP=1-3 AUTO\n#COMPACT\n#CELLADAPT\n##SYSTEM={Rhom,Tric,Mono,Cubi,Hexa,Orth,Tetra}\n\nKPOINTS_MP_SPACING 0.07\n\nSYMMETRY_GENERATE\nSNAP_TO_SYMMETRY\n\n%BLOCK SPECIES_POT\nQC5\n%ENDBLOCK SPECIES_POT\n\n%BLOCK EXTERNAL_PRESSURE\n0 0 0\n0 0\n0\n%ENDBLOCK EXTERNAL_PRESSURE","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"As you can see, the input file for buildcell is essentially an marked up cell file for CASTEP. Lines starting with # provides directives for buildcell, although those with ## will still be ignored.","category":"page"},{"location":"airss/#Options-for-buildcell","page":"AIRSS Background","title":"Options for buildcell","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"Several key tags are explained below:","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"VARVOL\nDefines the variable volume of the unit cell, the exact volume   will be randomise at a harded coded range of ± 5%. The actual unit   cell vectors will be randomised, and those in the LATTICE_CART   block takes no effect.\nPOSITIONS_ABC\nDefines the initial positions of the atoms in the unit cell. The   syntax after the # is <set name> % [<tags>...]. Where   <set name> can be used to define rigid fragments by setting the   same value for all of the linked sites. Since each atom should be   considered independently in this example, each line has a different   value. After the % comes the site-specific settings. The NUM   allows a single site to be multiplicated. For example, adding 12   oxygen atoms can achieved specified by O 0. 0. 0. # O % NUM=12   instead of doing it line by line.\nSYMOPS\nDefines the number of symmetry operations to be included in the   randomised structure. The - defines the range and a random value   will be drawn from.\nSGRANK\nThis tags can be enabled to bias the (randomly chosen) space group   towards those that are more frequently found in the ICSD. The value   defines a threshold rank for accepting the space group.\nNFORM\nThis tags defines the number of formula units to be included in the   generated structure. Here, the cell has the formula ceSr4Ti4O12   according to the POSITIONS_ABC block. If one changes NFORM to be   2, then the effective chemical formula would be ceSr8Ti8O24.   If NCORM is not defined, the composition will be affect by   SYMOPS, placing all atoms in the general positions.\nADJGEN\nThis tags is used to modify the number of general positions when   generating symmetry-containing structures. By default, the number of   general positions is maximised. This tags allows more special   postions to be occupied if possible. For blind search, there is no   need to use this tag in most cases.\nMINSEP\nThis tags defines the specie-wise minimum separations and is one of   the few tags that need to be manually changed by hand. The default   1-3 AUTO means to randomly set minimum separations per   specie-pair between 1 Å and 3 Å, but also try to extract and use   that of the best structure if possible. The latter part is achieved   by looking for a .minsep file in the current wroking directory,   which is generated by the airss.pl script on-the-fly. This   approach cannot be used by DIPS searches each calculation will be   run from different directories (and probably also different   machines). Initial values may be composed by the knowledge of common   bond lengths. The cryan -g command can also be used to extract   MINSEP from existing structures.\nSLACK,OVERLAP\nThese two tags controls the process of modifying the structure to   satisfy the minimum separations. Roughly speaking, a geometry   optimisation is performed ,each species-pair having a hard shell   potential. The tag SLACK defines how soft the hard shell   potential constructed will be, and OVERLAP defines the threshold   for acceptance. There is usually no need to vary these two tags.\nCOMPACT,CELLADAPT\nControls if the cell should be compacted and deformed based on the   hard shell potentials. There is usually no need to change these two   tags.\nSYSTEM\nAllows limiting the generated structure to certain crystal systems,   which can be useful to bias the search based on prior knowledge.","category":"page"},{"location":"airss/#Options-for-CASTEP","page":"AIRSS Background","title":"Options for CASTEP","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"Lines not marked up by # are often passed through, below are descriptions of some CASTEP-related tags that goes in the cell file.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"note: Note\nThe buildcell program will not always pass through the native CASTEP keys, so check the output cell carefully.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"KPOINTS_MP_SPACING\nDefines kpoints spacing in unit of mathrm2piÅ^-1. Usually   a not so well-converged setting can be used for the initial search.\nSYMMETRY_GENERATE\nLet CASTEP determine the symmetry for acclerating calculations. You   will almost always want to have this.\nSNAP_TO_SYMMETRY\nSnap the atoms to the positions according to the determined   symmetry. You will almost always want to have this.\nEXTERNAL_PRESSURE\nThe upper triangle of the external stress tenser. It does not get   passed through after buildcell.\nHUBBARD_U\nThe Hubbard-U values for each specie and orbital. For example,   Mn d:3 will apply an effective U of 3 eV to the d orbital of Mn.","category":"page"},{"location":"airss/#The-param-file","page":"AIRSS Background","title":"The param file","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The param file read by CASTEP only, and not used for building structure. A default param file for CASTEP from gencell looks like this:","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"task                 : geometryoptimization\nxc_functional        : PBE\nspin_polarized       : false\nfix_occupancy        : false\nmetals_method        : dm\nmixing_scheme        : pulay\nmax_scf_cycles       : 1000\ncut_off_energy       : 340 eV\nopt_strategy         : speed\npage_wvfns           : 0\nnum_dump_cycles      : 0\nbackup_interval      : 0\ngeom_method          : LBFGS\ngeom_max_iter        : 20\nmix_history_length   : 20\nfinite_basis_corr    : 0\nfixed_npw            : true\nwrite_cell_structure : true\nwrite_checkpoint     : none\nwrite_bib            : false\nwrite_otfg           : false\nwrite_cst_esp        : false\nwrite_bands          : false\nwrite_geom           : false\nbs_write_eigenvalues : false\ncalculate_stress     : true\n","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"Several tags that you may want to modify are:","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"xc_functional\nDefines the exchange-correlation functional to be used. Since PBE   often bias towards less bonded (larger volume) phases, one may want   to use PBEsol instead.\nspin_polarized\nIf set to true the calculation will be spin polarized. Note that   CASTEP does not have default set for each site, so one have to break   the symmetry manually in addition to setting this tag.\nfixed_npw\naka, fix the number of plane waves. CASTEP default to constant   basis-quality during variable-cell geometry geometry optmisation   rather than the constant basis set in many other plane wave codes.   While this allows getting a reliable final energy with restarts, the   castep_relax script already handles automatically restart anyway.   Having consistant basis-quality may not be optimum when large pulay   stress is present, e.g. using less well-converged cut off energies.   Hence, it is preferable to set it to true and use the constant   basis set approach.\ncut_off_energy\nThe cut off energy should be sufficient for the pseudopotential   used. There is no need to high quality but harder pseudopotentials   in the initial search in most case.\ngeom_method\nAlgorithm for geometry optmisation. LBFGS works well cases,   otherwise tpsd may be used instead.\nmixing_scheme\nThis tags controls the charge density mixer. The pulay mixer is OK   for most case, otherwise one can use broyden instead if   convergence struggles.\nmax_scf_cycles\nKeep a large value to avoid CASTEP giving up the structure due to   electronic convergence instability.\nopt_strategy\nUse speed to keep everything in the RAM and avoid any slow disk   IO.\ngeom_max_iter\nNumber of geometry optimisation per run. Since castep_relax will   repetively restart calculation, use a small value so the basis set   is reset every so often. For fixed cell optimisation, one can use a   large value in combination with apporiate castep_relax arguments   and avoid restarts.\nmetals_method\nUse dm (density mixing) for speed.","category":"page"},{"location":"airss/#airss.pl","page":"AIRSS Background","title":"airss.pl","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The main driver script for performing the search. It read command line arguments and performs random structure generation and runs DFT calculations in serial, and stop until the specified number of structure has been generated. Because the search is embarrsingly parallel, one can just launch as many airss.pl as they like to occupy all computational resources. For example, to sample 800 structure using 128 cores, one can launch 8 airss.pl script each using 16 cores and sampling 100 structures. The result of airss.pl are saved in the SHELX format with suffix res. These files contains both the crystal structure and the calculated quantities. While DISP does not use this script directly, it is recommanded that the user familiarise themselves with operating AIRSS using it.","category":"page"},{"location":"airss/#cryan","page":"AIRSS Background","title":"cryan","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"A tool to analyse the relaxed structures. It can be used to rank structures according to energy as well as eliminating nearly identical structures and extracting species-wise minimum distances. It also has many other advanced features as such decomposing a structure into modular units.","category":"page"},{"location":"airss/#cabal","page":"AIRSS Background","title":"cabal","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"A tool for convert different file formats. It is used internally by various scripts. One very useful feature is to convert file into SHELX format so they can be processed by cryan.","category":"page"},{"location":"airss/#castep_relax","page":"AIRSS Background","title":"castep_relax","text":"","category":"section"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"This is script supplied by the airss package. The main idea is to restart the DFT calculations every certain number of geometry step, in order to update the basis set when running in the fixed basis set mode with variable unit cell. By default, the script does several restarts with very small number of ionic steps, as it is expected that the volume could change significantly in the very begining. Afterwards, the geom_max_iter setting in the param is respected. The optimisation is terminated if CASTEP reports that the optimization is successful in two consecutive restats, of if the maximum number of steps has been reached.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"The input syntax is:","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"castep_relax <maxit> <exe> <sim> <symm> <seed>","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"These arguments are explained as below:","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"<maxit>: The maximum total number of geometry optimisation steps   among all restarts. The optimisation is assumed to be finished if   this number of steps has been reached.\n<exe>: The launch command for running CASTEP, including the MPI   launch command and its arguments.\n<sim>: Aswitch to enable check if the same structure has been   found before. It should be disabled by setting it to 0 in DISP, as   each calculation is run under a different directory.\nIf the <symm> switch is set to 1 the structure will be   symmetrised on-the-fly during the restarts. It is typically turned   off.\n<seed>: The name of the seed for CASTEP.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"[1]: Pickard, C. J.; Needs, R. J. Ab Initio Random Structure Searching. Journal of physics. Condensed matter : an Institute of Physics journal 2011, 23 (5), 053201–053201. https://doi.org/10.1088/0953-8984/23/5/053201.","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"[2]: Section 4.2.2, https://doi.org/10.17863/CAM.55681","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"[3]: Figure 7, https://doi.org/10.1016/j.cpc.2020.107810","category":"page"},{"location":"airss/","page":"AIRSS Background","title":"AIRSS Background","text":"[4]: Academic license for CASTEP can be obtained free of charge, see http://www.castep.org.","category":"page"},{"location":"gpu/#GPU-Acceleration","page":"-","title":"GPU Acceleration","text":"","category":"section"},{"location":"gpu/","page":"-","title":"-","text":"To enable GPU acceleration, you need to have a CUDA-enabled GPU and CUDA toolkit installed on your system. You can check if your system has CUDA support by running the following command in the terminal:","category":"page"},{"location":"gpu/","page":"-","title":"-","text":"nvidia-smi","category":"page"},{"location":"gpu/","page":"-","title":"-","text":"If you have CUDA support, you can enable GPU acceleration by setting the EDDPotential.USE_CUDA[] parameter to true. In addition, the CUDA.jl should be installed and loaded before running the code. Here is an example:","category":"page"},{"location":"gpu/","page":"-","title":"-","text":"using CUDA, EDDPotentials\n\nEDDPotential.USE_CUDA[] = true\n\nbu = Builder()\nfc = load_features(bu)\ntrain, test, valid = split(fc, 0.8, 0.1, 0.1);\nmodel = EDDPotentials.ManualFluxBackPropInterface(bu.cf, 10, 10;xt=train.xt, yt=train.yt)\n\ntrain!(model, training_data, test_data; show_progress=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#EDDPotentials.jl","page":"Home","title":"EDDPotentials.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Julia package that implements the Ephemeral data derived potentials (EDDP). EDDP can be seen as a kind of Machine Learning (Interatomic) Potentials (MLP).  Normally such potentials are aim at accurately reproduce the results of first-principles calculations to run large scale molecular dynamics simulation which are otherwise intractable with first-principles calculations. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"EDDP takes a simple and physically motivated form that resembles a generalized N-body Lenard-Jones-like potential, making it very easy to train. Being physically motivated allow EDDP to give sufficiently good representations for most of the configuration space, allowing crystal structure prediction to be carried out with much reduced computational resources and walltime. In many cases, EDDP can still give sufficiently accurate forces to allow molecular dynamics simulation and phonon properties.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generating EDDP feature vectors (local descriptors).\nTrain EDDP ensemble models.\nPerform geometry optimization using trained models. \nInterface to other package for property calculations.\nAutomated workflows for automated potential building and crystal structure prediction.\nTraining data generation using standard scheduler queue system.\nTraining data generation through DISP.\nAnalysis and visualisation for potential quality verification and convergence.","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"airss - ab initio random structure (AIRSS) is used for building random structure through the buildcell program included in the bundle.\neddp - The Fortran EDDP code. EDDPotentials.jl provides limited interoperability with the eddp fortran package. Although directly loading models trained by eddp is not implemented, the training datasets are compatible as both use the AIRSS-style SHELX format.\nCASTEP - A plane-wave DFT code used for efficient generation of training datasets, although in principle any atomistic modelling package that calculates total energy of a given structure is supported.\ndisp - Distributed structure prediction (DISP) package can be used to schedule and run data generation tasks (e.g. DFT calculations) on multiple remote computing clusters. ","category":"page"},{"location":"#Documentations","page":"Home","title":"Documentations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"getting_started.md\", \"faq.md\", \"python_tools.md\", \"airss.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = EDDPotentials","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/#Building-custom-system-image","page":"FAQ","title":"Building custom system image","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"NOTE: TTTX has been greatly improved since Julia 1.9 the notes below are mostly no longer relevant.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"At the time of writing, loading Julia modules comes with high latency in addition to the the so called time-to-first-X (TTFX) delay related to time spent on compiling native code in each fresh Julia session.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Such delays can be completely eliminated by compiling a system image using the PackageCompiler.jl, which contain EDDPotentials.jl, EDDPotentialsTools.jl and all its dependencies.  This can be done by simply following the documentation of the PackageCompiler.jl ","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"For development environment this is a bit more complicated while the inconvenience of compiler latency is more pronounce due to frequent session restarts. In this case, a special system image needs to be created that includes all dependencies of EDDPotentials.jl and EDDPotentialsTools.jl, plus some commonly used tools (such as BenchmarkTools.jl and Revise), but not EDDPotentials.jl and EDDPotentialsTools.jl themselves.  Create such system image, there is a sysimg.jl under the scripts folder that can used via:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia --project=<some project with PackageCompiler installed> -e 'include(\"sysimg.jl\");build()' ","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This creates the system image file at ~/.julia/eddpdev.so. To launch julia with the system image:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia -J ~/.julia/eddpdev.so","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia> \"Flux\" in [x.name for x in keys(Base.loaded_modules)]\ntrue","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"One should note that any packages compiled into the system image is essentially frozen-in - their version cannot be changed by Pkg. Hence, the system image must be rebuilt after any update of the Manifest.toml.","category":"page"}]
}
